<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mindfield</title>
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
    }
    #mindmap-container {
        width: 100%;
        height: 100%;
    }
    .node {
        pointer-events: all;
        cursor: pointer;
        transition: all 0.3s ease;
        z-index: 2;
    }
    .node:hover {
        filter: brightness(1.2);
    }
    .node circle.selected {
        stroke: #2bff00;
        stroke-width: 3px;
    }
    .node text.selected {
        fill: #2ca02c;
    }
    .node text {
        font-size: 12px;
        fill: #333;
    }
    .link {
        fill: none;
        stroke: #999;
        stroke-width: 2px;
    }
    #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        background-color: rgba(255, 255, 255, 0.6);
        padding: 5px;
        border-radius: 5px;
        pointer-events: none;
    }
    #controls button {
        pointer-events: auto;
        margin: 2px;
        padding: 3px 6px;
        cursor: pointer;
        font-size: 10px;
    }
    #toggle-grid.active {
        background-color: #333;
        color: #fff;
        border-color: #fff;
    }
    .selected {
        stroke: #2bff00;
        stroke-width: 1px;
        vector-effect: non-scaling-stroke;
    }
    .edit-field {
        position: absolute;
        background-color: white;
        border: 1px solid #999;
        padding: 2px;
        font-size: 12px;
    }
    .edit-field input {
        width: 100px;
        border: none;
        outline: none;
    }
    .edit-field button {
        background: none;
        border: none;
        padding: 2px;
        cursor: pointer;
    }
    .context-menu {
        position: absolute;
        background-color: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 5px;
        font-size: 12px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .context-menu-section {
        border-bottom: 1px solid #eee;
        padding: 5px 0;
    }
    .context-menu-section:last-child {
        border-bottom: none;
    }
    .context-menu .selected-node {
        color: #2ca02c;
        font-weight: bold;
    }
    .context-menu .node-id {
    font-size: 8px; /* Very tiny text */
    color: #666; /* Optional styling */
    }

    .bark {
    cursor: move;
    pointer-events: all;
}

.node circle:not(.bark) {
    pointer-events: all;
}

.node-circle {
    pointer-events: none;
}

.bark.dragging {
    opacity: 0.7;
}

.bark.overlapping {
    fill: #00ff00 !important;
    transition: fill 0.1s ease-in-out;
}

.internode {
    fill: none;
    stroke: #cccccc;  /* Lighter grey color */
    stroke-width: 3px;  /* Thicker line */
    cursor: pointer;  /* Change cursor to indicate clickability */
}

.internode path {
    fill: none;
    stroke: #00ff00;  /* Darker gray */
    stroke-width: 2px;
    stroke-dasharray: 4,4;  /* Dotted line */
    cursor: pointer;
}

    .color-option {
        width: 20px;
        height: 20px;
        display: inline-block;
        margin: 2px;
        border: 1px solid #999;
        cursor: pointer;
    }
    .hierarchy-tree {
        font-size: 10px;
        margin-left: 10px;
    }
    .hierarchy-tree div {
        cursor: pointer;
    }
    .hierarchy-tree div:hover {
        text-decoration: underline;
    }

    .mindfield-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 200px;
    top: 50px;
    width: 300px;
    background-color: #ffffff;
    border: 1px solid #999;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    font-size: 12px;
}

.mindfield-modal-topbar {
    background-color: #2b2b2b;
    color: white;
    padding: 5px 10px;
    cursor: move;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.mindfield-modal-title {
    font-size: 14px;
    font-weight: bold;
}

.mindfield-modal-close {
    cursor: pointer;
}

.mindfield-modal-tabs {
    display: flex;
    background-color: #f1f1f1;
}

.mindfield-tab-button {
    background-color: inherit;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 5px 10px;
    font-size: 11px;
}

.mindfield-tab-button:hover {
    background-color: #ffffff;
}

.mindfield-tab-button.active {
    background-color: #ffffff;
}

.mindfield-modal-content {
    padding: 10px;
}

.mindfield-tab-pane {
    display: none;
}

.mindfield-tab-pane.active {
    display: block;
}

#mindfield-background-type,
#mindfield-color-picker-container,
#mindfield-image-url-container {
    margin-bottom: 10px;
}

#mindfield-background-image-url {
    width: calc(100% - 50px);
    padding: 2px;
    font-size: 11px;
}

#mindfield-set-background-image {
    padding: 2px 5px;
    font-size: 11px;
}

.mindfield-modal h3 {
    font-size: 13px;
    margin: 0 0 10px 0;
}

    

    .grid {
        stroke: #e0e0e0;
        stroke-width: 1px;
    }
    .grid .thick {
        stroke: #a0a0a0;
        stroke-width: 5px;
        vector-effect: non-scaling-stroke;
    }
    .grid .selected {
        stroke: #ff0000;
        stroke-width: 5px;
        vector-effect: non-scaling-stroke;
    }
    .grid-label {
    fill: rgb(134, 134, 134);
    font-size: 48px;
    font-weight: bold;
    pointer-events: none;
    }
    #mini-map {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 200px;
        height: 200px;
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 5px;
        overflow: hidden;
    }
    #mini-map-controls {
        position: absolute;
        bottom: 5px;
        right: 3px;
    }
    #mini-map-controls button {
        width: 16px;
        height: 16px;
        font-size: 10px;
        padding: 0;
        margin: 0 2px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
    }
    @keyframes buttonPop {
        0% { transform: scale(1); }
        50% { transform: scale(0.95); }
        100% { transform: scale(1); }
    }
    #controls button:active,
    #mini-map-controls button:active {
        animation: buttonPop 0.1s ease-in-out;
    }

    #clear-red-lines {
    color: red;
}

    #grid-navigation {
    position: absolute;
    bottom: 5px;
    right: 108px; /* Adjust based on your mini-map width */
    display: flex;
    align-items: center;
    }

    #grid-navigation input {
    width: 50px;
    margin-right: 5px;
    padding: 0px;
    font-size: 12px;
    border: 1px solid #d3d3d3; /* Light gray border */
    border-radius: 2px;
    }

    #grid-navigation input:focus {
    outline: none;
    border-color: #a9a9a9; /* Slightly darker gray when focused */
    box-shadow: 0 0 2px #d3d3d3; /* Subtle shadow for focus effect */
    }

    #mini-menu {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        font-size: 10px;
        max-width: 400px;
        display: none;
    }
    #mini-menu h3 {
        margin-top: 0;
        font-size: 14px;
    }
    #mini-menu ul {
        padding-left: 20px;
        margin-bottom: 0;
    }
    #mini-menu li {
        margin-bottom: 5px;
    }
    #close-help-menu {
            position: absolute;
            top: 5px;
            right: 5px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
        }
        .tab-content {
            height: 400px;
            position: relative;
        }
        .tab {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        .tab:first-child {
            display: block;
        }
        .tab h3 {
            margin-top: 0;
            color: #333;
        }
        .tab ul, .tab ol {
            padding-left: 20px;
            margin: 5px 0;
        }
        .tab-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        .nav-button-container {
            width: 60px;
            display: flex;
            justify-content: center;
        }
        .tab-dots {
            display: flex;
            justify-content: center;
            flex-grow: 1;
        }
        .dot {
            height: 10px;
            width: 10px;
            background-color: #bbb;
            border-radius: 50%;
            display: inline-block;
            margin: 0 5px;
            cursor: pointer;
        }
        .dot.active {
            background-color: #717171;
        }
        .demo-button {
            font-size: 12px;
            padding: 2px 5px;
            margin-right: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
        }
        #prevTab, #nextTab {
            display: block;
            visibility: hidden;
            font-size: 12px;
            padding: 2px 5px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
        }
        .space-window {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.7);
    border: 1px solid #ccc;
    min-width: 100px;
    min-height: 300px; /* Increased from previous value */
    height: 400px; /* Set a taller default height */
    pointer-events: auto;
    z-index: 1;
    overflow: hidden;
    cursor: default;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .space-window-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #f0f0f0;
    padding: 2px 5px;
    cursor: move;
    font-size: 12px;
    height: 20px;
}

.space-window-title {
    flex-grow: 1;
    margin-right: 10px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.space-window-node-info {
    flex-grow: 1;
    text-align: center;
    font-size: 10px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.space-window-pin {
    margin-right: 10px;
    font-size: 10px;
}

.space-window-controls {
    display: flex;
    align-items: center;
}

.space-window-minimize,
.space-window-close {
    cursor: pointer;
    padding: 0 5px;
    font-size: 16px;
}

.space-window-minimize {
    margin-right: 5px;
}
    .space-window-content {
        display: flex;
        flex-wrap: wrap;
        height: calc(100% - 0px);
        overflow-x: auto;
        padding: 5px;
    }
    .space-window-column {
        flex: 1 0 200px;
        min-width: 200px;
        max-width: 400px;
        margin: 5px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 5px;
        position: relative;
        overflow-y: auto;
    }
    .column-separator {
        width: 5px;
        background-color: #ccc;
        cursor: col-resize;
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
    }
    .space-window-close {
        float: right;
        cursor: pointer;
    }
    .space-window-resize {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 10px;
        height: 10px;
        cursor: nwse-resize;
    }
    
    .add-element-modal {
        position: absolute;
        background-color: white;
        border: 1px solid #ccc;
        padding: 10px;
        z-index: 3;
    }
    .modal-title {
        font-size: 12px;
        margin: 0 0 10px 0;
    }
    .modal-buttons button {
        font-size: 10px;
        padding: 2px 4px;
        margin-right: 5px;
    }
    .modal-close {
        position: absolute;
        top: 5px;
        right: 5px;
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
    }
    .demo-button {
        font-size: 10px;
        padding: 2px 4px;
        margin-right: 5px;
    }
    .space-element {
        width: 100%;
        max-width: 100%;
        overflow: hidden;
        margin-bottom: 10px;
        position: relative;
        padding-left: 52px;
        cursor: pointer;
    }
    .thought-element {
        background-color: #f0f0f0;
        padding: 5px;
        border-radius: 5px;
    }
    .image-element img {
        width: 100px;
        height: 100px;
        object-fit: contain;
    }
    .image-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border: 1px solid #ccc;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        z-index: 1000;
    }
    .image-modal-header {
        margin-bottom: 10px;
    }
    .place-element a {
        text-decoration: underline;
        color: #333;
    }
    .tree-element ul {
        margin-left: 20px;
    }
    .add-child-button {
        font-size: 10px;
        margin-left: 5px;
        cursor: pointer;
    }
    .image-preview {
        position: absolute;
        z-index: 1000;
    }
    .column-dropdown {
        font-size: 10px;
        padding: 2px;
        margin-bottom: 5px;
        width: 100%;
    }
    .thought-modal,
    .place-modal,
    .tree-modal {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border: 1px solid #ccc;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        z-index: 1000;
    }
    .thought-modal-header,
    .place-modal-header,
    .tree-modal-header {
        margin-bottom: 10px;
    }
    .thought-modal input,
    .place-modal input,
    .tree-modal input {
        display: block;
        margin-bottom: 10px;
        width: 100%;
    }
    .thought-modal button,
    .place-modal button,
    .tree-modal button {
        margin-right: 10px;
    }
    .tree-element {
    position: relative;
    min-height: 200px;
}

.tree-orientation-button {
    position: absolute;
    top: 30px; /* Adjust this value to fine-tune vertical position */
    left: 2.5%;
    transform: translateX(-50%);
    background-color: #ffffff;
    border: 1px solid #ccc;
    border-radius: 2px;
    width: 18px;
    height: 18px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 10;
}

.tree-orientation-button span {
    font-size: 14px;
    line-height: 1;
}

.tree-element svg {
    display: block;
    margin: auto;
        overflow: visible;
    }
    .tree-element .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
    }
    .tree-element .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 3px;
    }
    .tree-element .node text {
        font: 12px sans-serif;
    }
    .tree-line {
        position: absolute;
        background-color: #000;
    }
    .tree-modal {
        max-height: 80vh;
        overflow-y: auto;
        resize: both;
    }
    
    .add-to-grid-button {
    font-size: 12px; /* Smaller font size */
    padding: 2px 4px; /* Reduced padding to make the button smaller */
    margin-top: 5px;
    margin-right: 5px; /* Add some right margin */
    margin-left: -1px; /* Move slightly to the left */
    background-color: #ffffff;
    border: 1px solid #ccc;
    border-radius: 3px;
    cursor: pointer;
    }
    .remove-column-button,
    .edit-element-button,
    .delete-element-button {
        position: absolute;
        font-size: 10px;
        padding: 2px 4px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
    }
    .edit-element-button {
        left: 0;
        top: 5px;
    }
    .delete-element-button {
        left: 26px;
        top: 5px;
    }
    .add-element-button {
    width: calc(100% - 20px); /* Full width with some margin */
    padding: 10px 15px;
    margin: 10px;
    cursor: pointer;
    background-color: #4CAF50; /* Green background */
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    text-transform: uppercase;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    position: relative;
    overflow: hidden;
}

.add-element-button:hover {
    background-color: #45a049;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transform: translateY(-2px);
}

.add-element-button:active {
    background-color: #3e8e41;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    transform: translateY(1px);
}

.add-element-button::before {
    content: "+";
    position: absolute;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 24px;
    font-weight: bold;
}
.add-column-button {
    width: calc(50% - 20px); /* Twice as wide as before, with some margin */
    height: 40px; /* Fixed height for better proportion */
    padding: 5px 10px;
    margin: 10px;
    cursor: pointer;
    background-color: #fffafa; /* White background */
    color: #333;
    border: 2px dashed #999; /* Keeping the dotted (dashed) border */
    border-radius: 5px;
    font-size: 14px;
    font-weight: bold;
    text-align: center;
    transition: all 0.3s ease;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
}

.add-column-button:hover {
    background-color: #f1f1f1;
    border-color: #666;
}

.add-column-button:active {
    background-color: #d0d0d0;
    transform: translateY(1px);
}

.add-column-button::before {
    content: "+";
    font-size: 20px;
    margin-right: 8px;
    font-weight: bold;
}
    .resize-handle {
        position: absolute;
        width: 10px;
        height: 10px;
        background-color: #ccc;
        right: 0;
        bottom: 0;
        cursor: nwse-resize;
    }
    .image-url {
        color: #444;
        text-decoration: underline;
        margin-bottom: 10px;
    }
    .image-details {
        color: #666;
        font-size: 12px;
        margin-top: 10px;
    }
</style>
</head>
<body>
    <div id="controls">
        <button id="add-child">Add Child</button>
        <button id="remove-node">Remove Node</button>
        <button id="save">Save</button>
        <button id="load">Load</button>
        <button id="reset-zoom">Reset Zoom</button>
        <button id="toggle-grid">Toggle Grid</button>
        <button id="toggle-help">Help</button>
        <button id="mindfield-settings-button">⚙️</button>
    </div>
    <div id="mini-map"></div>
    <div id="grid-navigation">
        <input type="number" id="x-coordinate" placeholder="X" min="0" max="100">
        <input type="number" id="y-coordinate" placeholder="Y" min="0" max="100">
    </div>
    <div id="mini-map-controls">
        <button id="clear-red-lines" title="Clear Red Lines">#</button>
        <button id="focus-mini-map" title="Show Full Grid">⊡</button>
        <button id="reset-mini-map" title="Go to Top-Left Corner">↖</button>
    </div>
    <div id="mini-menu">
        <button id="close-help-menu" onclick="toggleHelpMenu()">×</button>
        <div class="tab-content">
            <div class="tab" id="tab1">
                <h3>Basic Controls</h3>
                <ul>
                    <li><button class="demo-button" onclick="simulateAddChild()">Add Child</button> Add a new child node to the selected node.</li>
                    <li><button class="demo-button" onclick="simulateRemoveNode()">Remove Node</button> Remove the selected node.</li>
                    <li><button class="demo-button" onclick="simulateSave()">Save</button> Save the current mind map.</li>
                    <li><button class="demo-button" onclick="simulateLoad()">Load</button> Load a saved mind map.</li>
                    <li><button class="demo-button" onclick="simulateResetZoom()">Reset Zoom</button> Reset the zoom level.</li>
                    <li><button class="demo-button" onclick="simulateToggleGrid()">Toggle Grid</button> Show/hide the grid.</li>
                    <li>Double-click a node to edit its text.</li>
                    <li>Right-click a node to open the context menu.</li>
                    <li>Drag nodes to reposition them.</li>
                    <li>Use the mini-map to navigate the mind map.</li>
                </ul>
            </div>
            <div class="tab" id="tab2">
                <h3>Advanced Features</h3>
                <ul>
                    <li><button class="demo-button" onclick="simulateAddSpace()">Add Space</button> Create a new Space window for additional content.</li>
                    <li>Spaces can contain multiple columns and elements:</li>
                    <ul>
                        <li>Images: Add and preview images.</li>
                        <li>Thoughts: Add formatted text notes.</li>
                        <li>Places: Add links to external resources.</li>
                        <li>Trees: Create hierarchical structures.</li>
                    </ul>
                    <li>Edit or delete elements using the buttons on each item.</li>
                    <li>Resize Space windows using the handle in the bottom-right corner.</li>
                    <li>Double-click a Space window's title to edit its name.</li>
                    <li>Node colors: Right-click a node and use the color picker in the context menu to change its color.</li>
                </ul>
            </div>
            <div class="tab" id="tab3">
                <h3>Trees</h3>
                <ul>
                    <li>Trees are hierarchical structures that can be added to Space windows.</li>
                    <li>To create a tree:</li>
                    <ol>
                        <li>Click "Add Element" in a Space window.</li>
                        <li>Select "Tree" from the options.</li>
                        <li>Use the tree editor to add, edit, or remove nodes.</li>
                    </ol>
                    <li>To add a tree to the main grid:</li>
                    <ol>
                        <li>Select a node in the main mind map.</li>
                        <li>Click the "Add to Grid" button on a tree in a Space window.</li>
                        <li>The tree will be added as a series of connected nodes, with each tree node becoming a separate node in the mind map.</li>
                    </ol>
                    <li>Edit trees in Space windows by clicking the edit button (✎) on the tree element.</li>
                    <li>Trees added to the grid become part of the main mind map structure and can be manipulated like other nodes.</li>
                    <li>Changes to the original tree in the Space window will not automatically update the nodes added to the grid until the Node structure is interacted with.</li>
                </ul>
            </div>
            <div class="tab" id="tab4">
                <h3>Grid and Navigation</h3>
                <ul>
                    <li>Use the grid to organize your mind map into zones.</li>
                    <li>Click on thick grid lines to highlight them.</li>
                    <li>Nodes within highlighted zones will be marked.</li>
                    <li>Mini-map controls:</li>
                    <ul>
                        <li><button class="demo-button" onclick="simulateResetMiniMap()">↖</button> Go to top-left corner.</li>
                        <li><button class="demo-button" onclick="simulateFocusMiniMap()">⊡</button> Show full grid.</li>
                    </ul>
                    <li>Click on the mini-map to quickly navigate to different areas.</li>
                </ul>
            </div>
        </div>
        <div class="tab-navigation">
            <div class="nav-button-container">
                <button id="prevTab" onclick="changeTab(-1)">Prev</button>
            </div>
            <div class="tab-dots">
                <span class="dot active" onclick="jumpToTab(0)"></span>
                <span class="dot" onclick="jumpToTab(1)"></span>
                <span class="dot" onclick="jumpToTab(2)"></span>
                <span class="dot" onclick="jumpToTab(3)"></span>
            </div>
            <div class="nav-button-container">
                <button id="nextTab" onclick="changeTab(1)">Next</button>
            </div>
        </div>
    </div>

    <div id="mindfield-settings-modal" class="mindfield-modal">
        <div class="mindfield-modal-topbar">
            <span class="mindfield-modal-title">Mindfield Settings</span>
            <span class="mindfield-modal-close">&times;</span>
        </div>
        <div class="mindfield-modal-tabs">
            <button class="mindfield-tab-button active" data-tab="mindfield-appearance">Appearance</button>
            <button class="mindfield-tab-button" data-tab="mindfield-tab2">Tab 2</button>
            <button class="mindfield-tab-button" data-tab="mindfield-tab3">Tab 3</button>
            <button class="mindfield-tab-button" data-tab="mindfield-tab4">Tab 4</button>
        </div>
        <div class="mindfield-modal-content">
            <div id="mindfield-appearance" class="mindfield-tab-pane active">
                <h3>Background</h3>
                <div id="mindfield-background-type">
                    <label>
                        <input type="radio" name="mindfield-bg-type" value="color" checked> Color
                    </label>
                    <label>
                        <input type="radio" name="mindfield-bg-type" value="image"> Image
                    </label>
                </div>
                <div id="mindfield-color-picker-container">
                    <input type="color" id="mindfield-background-color" value="#f0f0f0">
                </div>
                <div id="mindfield-image-url-container" style="display:none;">
                    <input type="text" id="mindfield-background-image-url" placeholder="Enter image URL">
                    <button id="mindfield-set-background-image">Set</button>
                </div>
            </div>
            <div id="mindfield-tab2" class="mindfield-tab-pane">
                <p>Coming Soon</p>
            </div>
            <div id="mindfield-tab3" class="mindfield-tab-pane">
                <p>Coming Soon</p>
            </div>
            <div id="mindfield-tab4" class="mindfield-tab-pane">
                <p>Coming Soon</p>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 0;

        function initializeHelpMenu() {
            const tabs = document.querySelectorAll('.tab');
            document.getElementById('prevTab').style.visibility = 'hidden';
            document.getElementById('nextTab').style.visibility = tabs.length > 1 ? 'visible' : 'hidden';
        }

        function changeTab(direction) {
            const tabs = document.querySelectorAll('.tab');
            const dots = document.querySelectorAll('.dot');
            
            tabs[currentTab].style.display = 'none';
            dots[currentTab].classList.remove('active');
            
            currentTab += direction;
            if (currentTab >= tabs.length) currentTab = 0;
            if (currentTab < 0) currentTab = tabs.length - 1;
            
            tabs[currentTab].style.display = 'block';
            dots[currentTab].classList.add('active');
            
            updateNavButtons();
        }

        function jumpToTab(tabIndex) {
            const tabs = document.querySelectorAll('.tab');
            const dots = document.querySelectorAll('.dot');
            
            tabs[currentTab].style.display = 'none';
            dots[currentTab].classList.remove('active');
            
            currentTab = tabIndex;
            
            tabs[currentTab].style.display = 'block';
            dots[currentTab].classList.add('active');
            
            updateNavButtons();
        }

        function updateNavButtons() {
            const tabs = document.querySelectorAll('.tab');
            document.getElementById('prevTab').style.visibility = currentTab === 0 ? 'hidden' : 'visible';
            document.getElementById('nextTab').style.visibility = currentTab === tabs.length - 1 ? 'hidden' : 'visible';
        }

        function toggleHelpMenu() {
            const miniMenu = document.getElementById('mini-menu');
            if (miniMenu.style.display === 'none') {
                miniMenu.style.display = 'block';
                initializeHelpMenu();
            } else {
                miniMenu.style.display = 'none';
            }
        }

        // Simulation functions (these would be connected to your actual mind map functionality)
        function simulateAddChild() { alert("Add Child clicked"); }
        function simulateRemoveNode() { alert("Remove Node clicked"); }
        function simulateSave() { alert("Save clicked"); }
        function simulateLoad() { alert("Load clicked"); }
        function simulateResetZoom() { alert("Reset Zoom clicked"); }
        function simulateToggleGrid() { alert("Toggle Grid clicked"); }
        function simulateAddSpace() { alert("Add Space clicked"); }
        function simulateResetMiniMap() { alert("Reset Mini-Map clicked"); }
        function simulateFocusMiniMap() { alert("Focus Mini-Map clicked"); }

        // Initialize the help menu when the page loads
        document.addEventListener('DOMContentLoaded', initializeHelpMenu);
    </script>
    <div id="space-windows"></div>
    <div id="mindmap-container"></div>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Include Quill for the thought editor -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    <script>
    // Helper functions and variables
    function getExistingColumns(content) {
        const columns = content.selectAll(".space-window-column");
        const columnNames = columns.size() ? columns.nodes().map((_, i) => `Column ${i + 1}`) : ["Column 1"];
        return columnNames;
    }

    
    document.addEventListener('DOMContentLoaded', function() {
    const modal = document.getElementById('mindfield-settings-modal');
    const settingsBtn = document.getElementById('mindfield-settings-button');
    const closeBtn = modal.querySelector('.mindfield-modal-close');
    const topBar = modal.querySelector('.mindfield-modal-topbar');
    const tabButtons = modal.querySelectorAll('.mindfield-tab-button');
    const tabContents = modal.querySelectorAll('.mindfield-tab-pane');
    const bgTypeRadios = modal.querySelectorAll('input[name="mindfield-bg-type"]');
    const colorPicker = document.getElementById('mindfield-background-color');
    const imageUrlInput = document.getElementById('mindfield-background-image-url');
    const setImageBtn = document.getElementById('mindfield-set-background-image');

    settingsBtn.addEventListener('click', function() {
        modal.style.display = "block";
    });

    closeBtn.addEventListener('click', function() {
        modal.style.display = "none";
    });

    tabButtons.forEach(button => {
        button.addEventListener('click', () => {
            const tab = button.dataset.tab;
            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            button.classList.add('active');
            document.getElementById(tab).classList.add('active');
        });
    });

    bgTypeRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            if (e.target.value === 'color') {
                document.getElementById('mindfield-color-picker-container').style.display = 'block';
                document.getElementById('mindfield-image-url-container').style.display = 'none';
            } else {
                document.getElementById('mindfield-color-picker-container').style.display = 'none';
                document.getElementById('mindfield-image-url-container').style.display = 'block';
            }
        });
    });

    colorPicker.addEventListener('change', (e) => {
        document.body.style.backgroundColor = e.target.value;
    });

    setImageBtn.addEventListener('click', () => {
        const imageUrl = imageUrlInput.value;
        if (imageUrl) {
            document.body.style.backgroundImage = `url(${imageUrl})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundPosition = 'center';
        }
    });

    // Make the modal draggable
    let isDragging = false;
    let startX, startY, startLeft, startTop;

    topBar.addEventListener('mousedown', startDragging);

    function startDragging(e) {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        startLeft = modal.offsetLeft;
        startTop = modal.offsetTop;
        document.addEventListener('mousemove', drag);
        document.addEventListener('mouseup', stopDragging);
    }

    function drag(e) {
        if (isDragging) {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            modal.style.left = startLeft + dx + 'px';
            modal.style.top = startTop + dy + 'px';
        }
    }

    function stopDragging() {
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('mouseup', stopDragging);
    }
});


    function addElementToColumn(column, element) {
        column.node().appendChild(element.node());
    }
    
    function showAddElementModal(content, event) {
        const modal = d3.select("body").append("div")
            .attr("class", "add-element-modal")
            .style("left", `${event.pageX}px`)
            .style("top", `${event.pageY}px`);

        modal.append("div")
            .attr("class", "modal-title")
            .text("Add Element");

        const columnDropdown = modal.append("select")
            .attr("class", "column-dropdown");

        const existingColumns = getExistingColumns(content);
        existingColumns.forEach((columnName, index) => {
            columnDropdown.append("option")
                .attr("value", columnName)
                .text(columnName);
        });
    
        modal.append("button")
            .attr("class", "modal-close")
            .html("&times;")
            .style("position", "absolute")
            .style("top", "5px")
            .style("right", "5px")
            .on("click", () => modal.remove());

        const buttonContainer = modal.append("div")
            .attr("class", "modal-buttons");

        buttonContainer.append("button")
            .text("Image")
            .on("click", () => addImage(content, modal, columnDropdown));

        buttonContainer.append("button")
            .text("Thought")
            .on("click", () => addThought(content, modal, columnDropdown));

        buttonContainer.append("button")
            .text("Place")
            .on("click", () => addPlace(content, modal, columnDropdown));

        buttonContainer.append("button")
            .text("Tree")
            .on("click", () => addTree(content, modal, columnDropdown));
    }
    
    function generateElementId() {
        return Math.floor(100000000000000000 + Math.random() * 900000000000000000).toString();
    }

    function generateNodeId() {
        return Math.floor(100000000000000000 + Math.random() * 900000000000000000).toString();
    }

    function addImage(content, modal, columnDropdown, existingElement = null) {
        const imageModal = d3.select("body").append("div")
            .attr("class", "image-modal");

        imageModal.append("div")
            .attr("class", "image-modal-header")
            .text(existingElement ? "Edit Image" : "Add Image");

        const input = imageModal.append("input")
            .attr("type", "text")
            .attr("placeholder", "Enter image URL");

        if (existingElement) {
            input.property("value", existingElement.select("img").attr("src"));
        }
    
        imageModal.append("button")
            .text(existingElement ? "Update" : "Add")
            .on("click", function() {
                const url = input.property("value");
                if (url) {
                    if (existingElement) {
                        existingElement.select("img").attr("src", url);
                    } else {
                        const selectedColumnIndex = columnDropdown.property("value").replace("Column ", "") - 1;
                        const targetColumn = content.selectAll(".space-window-column").nodes()[selectedColumnIndex];

                        const newElement = d3.create("div")
                            .attr("class", "space-element image-element")
                            .style("position", "relative")
                            .attr("data-element-id", generateElementId());

                        newElement.append("img")
                            .attr("src", url)
                            .attr("alt", "User-added image")
                            .style("width", "100px")
                            .style("height", "100px")
                            .style("object-fit", "contain")
                            .on("click", function() {
                                showImageModal(url);
                            })
                            .on("mouseover", function(event) {
                                showImagePreview(event, this, url);
                            })
                            .on("mouseout", hideImagePreview);

                        addEditButton(newElement, "image");
                        addDeleteButton(newElement);
                        addElementToColumn(d3.select(targetColumn), newElement);
                    }
                }
                imageModal.remove();
                if (modal) modal.remove();
            });
    
            imageModal.append("button")
            .text("Cancel")
            .on("click", () => imageModal.remove());
    }

    function addThought(content, modal, columnDropdown, existingElement = null) {
        const thoughtModal = d3.select("body").append("div")
            .attr("class", "thought-modal");

        thoughtModal.append("div")
            .attr("class", "thought-modal-header")
            .text(existingElement ? "Edit Thought" : "Add Thought");

        const editor = thoughtModal.append("div")
            .attr("id", "thought-editor")
            .style("height", "200px");

        const quill = new Quill('#thought-editor', {
            theme: 'snow'
        });

        if (existingElement) {
            quill.root.innerHTML = existingElement.select(".thought-content").html();
        }
    
        thoughtModal.append("button")
            .text(existingElement ? "Update" : "Add")
            .on("click", function() {
            const thoughtText = quill.root.innerHTML;
            if (thoughtText) {
                if (existingElement) {
                    existingElement.select(".thought-content").html(thoughtText);
                } else {
                    const selectedColumnIndex = parseInt(columnDropdown.property("value").replace("Column ", "")) - 1;
                    const targetColumn = content.selectAll(".space-window-column").nodes()[selectedColumnIndex];

                    const newElement = d3.select(targetColumn).append("div")
                        .attr("class", "space-element thought-element")
                        .style("width", "100%")
                        .style("overflow", "auto")
                        .attr("data-element-id", generateElementId());

                    newElement.append("div")
                        .attr("class", "thought-content")
                        .html(thoughtText);

                    addEditButton(newElement, "thought");
                    addDeleteButton(newElement);
                }
            }
            thoughtModal.remove();
            if (modal) modal.remove();
        });
    
        thoughtModal.append("button")
            .text("Cancel")
            .on("click", () => thoughtModal.remove());
    }

    function addPlace(content, modal, columnDropdown, existingElement = null) {
        const placeModal = d3.select("body").append("div")
            .attr("class", "place-modal");

        placeModal.append("div")
            .attr("class", "place-modal-header")
            .text(existingElement ? "Edit Place" : "Add Place");

        const nameInput = placeModal.append("input")
            .attr("type", "text")
            .attr("placeholder", "Enter place name");

        const urlInput = placeModal.append("input")
            .attr("type", "text")
            .attr("placeholder", "Enter URL");

        if (existingElement) {
            nameInput.property("value", existingElement.select("a").text());
            urlInput.property("value", existingElement.select("a").attr("href"));
        }
    
        placeModal.append("button")
            .text(existingElement ? "Update" : "Add")
            .on("click", function() {
                const name = nameInput.property("value");
                const url = urlInput.property("value");
                if (name && url) {
                    if (existingElement) {
                        existingElement.select("a").text(name).attr("href", url);
                    } else {
                        const selectedColumnIndex = parseInt(columnDropdown.property("value").replace("Column ", "")) - 1;
                        const targetColumn = content.selectAll(".space-window-column").nodes()[selectedColumnIndex];

                        const newElement = d3.select(targetColumn).append("div")
                            .attr("class", "space-element place-element")
                            .style("width", "100%")
                            .style("overflow", "hidden")
                            .attr("data-element-id", generateElementId());

                        newElement.append("a")
                            .attr("href", url)
                            .attr("target", "_blank")
                            .style("color", "#333")
                            .style("text-decoration", "underline")
                            .text(name);

                        addEditButton(newElement, "place");
                        addDeleteButton(newElement);
                    }
                }
                placeModal.remove();
                if (modal) modal.remove();
            });
    
        placeModal.append("button")
            .text("Cancel")
            .on("click", () => placeModal.remove());
    }
    
    function addTree(content, modal, columnDropdown, existingElement = null, existingTreeData = null, nodeNameToAddChild = null) {
        const treeModal = d3.select("body").append("div")
            .attr("class", "tree-modal")
            .style("position", "fixed")
            .style("top", "50%")
            .style("left", "50%")
            .style("transform", "translate(-50%, -50%)")
            .style("background-color", "white")
            .style("padding", "20px")
            .style("border", "1px solid #ccc")
            .style("box-shadow", "0 4px 8px rgba(0,0,0,0.1)")
            .style("z-index", "1000")
            .style("min-width", "300px")
            .style("min-height", "400px");

        treeModal.append("div")
            .attr("class", "tree-modal-header")
            .text(existingElement ? "Edit Tree" : "Add Tree");

        const treeContent = treeModal.append("div")
            .attr("class", "tree-content")
            .style("max-height", "300px")
            .style("overflow-y", "auto");
    
            let treeData;
        if (existingElement || existingTreeData) {
            treeData = existingTreeData || JSON.parse(existingElement.attr("data-tree"));
            if (nodeNameToAddChild) {
                function addNodeToTree(treeNode, targetNodeName) {
                    if (treeNode.name === targetNodeName) {
                        if (!treeNode.children) treeNode.children = [];
                        treeNode.children.push({ name: "New Node" });
                        return true;
                    } else if (treeNode.children) {
                        for (let child of treeNode.children) {
                            if (addNodeToTree(child, targetNodeName)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                addNodeToTree(treeData, nodeNameToAddChild);
            }
            loadExistingTree(treeContent, treeData);
        } else {
            addTreeItem(treeContent, "root");
        }
    
        treeModal.append("button")
        .text(existingElement ? "Update" : "Add")
        .on("click", function() {
            const updatedTreeData = generateTreeData(treeContent);

            if (existingElement) {
                existingElement.attr("data-tree", JSON.stringify(updatedTreeData));
                updateTreeElement(existingElement);
            } else {
                const selectedColumnIndex = parseInt(columnDropdown.property("value").replace("Column ", "")) - 1;
                const targetColumn = content.selectAll(".space-window-column").nodes()[selectedColumnIndex];

                const newElement = d3.select(targetColumn).append("div")
                    .attr("class", "space-element tree-element")
                    .attr("data-tree", JSON.stringify(updatedTreeData))
                    .attr("data-element-id", generateElementId());

                renderTree(newElement, updatedTreeData);
                addEditButton(newElement, "tree");
                addDeleteButton(newElement);

                newElement.append("button")
                    .attr("class", "add-to-grid-button")
                    .text("Add to Selected Node")
                    .on("click", function() {
                        const gridId = addTreeToGrid(updatedTreeData);
                        newElement.attr("data-grid-id", gridId);
                    });
            }
            treeModal.remove();
            if (modal) modal.remove();
        });

    
            treeModal.append("button")
            .text("Cancel")
            .on("click", () => treeModal.remove());
    }
    
    function loadExistingTree(container, data) {
        function recursiveLoad(parentContainer, nodeData, level = 0) {
            const item = addTreeItem(parentContainer, level === 0 ? "root" : "branch", level);
            item.select("input").property("value", nodeData.name);
            if (nodeData.children) {
                nodeData.children.forEach(child => recursiveLoad(item, child, level + 1));
            }
        }
        recursiveLoad(container, data);
    }
    
    function addTreeToGrid(treeData) {
        if (!selectedNode) {
            alert("Please select a node on the grid to attach the tree.");
            return;
        }
        const parentNode = d3.select(selectedNode).datum();
    
        function createGridNode(treeNode, parent) {
            const gridNode = {
                id: generateNodeId(),
                name: treeNode.name,
                children: [],
                x: parent.x + 100,
                y: parent.y + (parent.children ? parent.children.length * 50 : 0),
                color: colorOptions[Math.floor(Math.random() * colorOptions.length)]
            };
            if (treeNode.children) {
                for (let child of treeNode.children) {
                    const childGridNode = createGridNode(child, gridNode);
                    gridNode.children.push(childGridNode);
                }
            }
            return gridNode;
        }
    
        const rootNode = createGridNode(treeData, parentNode);
    
        if (!parentNode.data.children) parentNode.data.children = [];
        parentNode.data.children.push(rootNode);
    
        update(data);
        return rootNode.id;
    }
    
    function updateGridTree(gridId, treeData) {
        function findNodeById(node, id) {
            if (node.id === id) return node;
            if (node.children) {
                for (let child of node.children) {
                    const found = findNodeById(child, id);
                    if (found) return found;
                }
            }
            return null;
        }
    
        const gridNode = findNodeById(data, gridId);
        if (gridNode) {
            gridNode.name = treeData.name;
            gridNode.children = [];
    
            function createGridNode(treeNode, parent) {
                const gridNode = {
                    id: generateNodeId(),
                    name: treeNode.name,
                    children: [],
                    x: parent.x + 100,
                    y: parent.y + (parent.children ? parent.children.length * 50 : 0),
                    color: colorOptions[Math.floor(Math.random() * colorOptions.length)]
                };
                if (treeNode.children) {
                    for (let child of treeNode.children) {
                        const childGridNode = createGridNode(child, gridNode);
                        gridNode.children.push(childGridNode);
                    }
                }
                return gridNode;
            }
    
            if (treeData.children) {
                for (let child of treeData.children) {
                    const childGridNode = createGridNode(child, gridNode);
                    gridNode.children.push(childGridNode);
                }
            }
            update(data);
        }
    }
    
    function showImagePreview(event, img, url) {
        const preview = d3.select("body").append("div")
            .attr("class", "image-preview")
            .style("position", "absolute")
            .style("left", `${event.pageX + 10}px`)
            .style("top", `${event.pageY + 10}px`)
            .style("z-index", "1000")
            .style("background-color", "white")
            .style("border", "1px solid #ccc")
            .style("box-shadow", "0 0 10px rgba(0,0,0,0.1)")
            .style("padding", "5px");
    
        preview.append("img")
            .attr("src", url)
            .style("max-width", "300px")
            .style("max-height", "300px");
    }
    
    function hideImagePreview() {
        d3.select(".image-preview").remove();
    }
    
    function showImageModal(url) {
        const modal = d3.select("body").append("div")
            .attr("class", "image-modal")
            .style("position", "fixed")
            .style("top", "50%")
            .style("left", "50%")
            .style("transform", "translate(-50%, -50%)")
            .style("background-color", "white")
            .style("padding", "20px")
            .style("border", "1px solid #ccc")
            .style("box-shadow", "0 4px 8px rgba(0,0,0,0.1)")
            .style("z-index", "1000");
    
        modal.append("a")
            .attr("class", "image-url")
            .attr("href", url)
            .attr("target", "_blank")
            .text(url);
    
        const img = modal.append("img")
            .attr("src", url)
            .style("max-width", "90vw")
            .style("max-height", "70vh");
    
        const detailsDiv = modal.append("div")
            .attr("class", "image-details");
    
        img.on("load", function() {
            const this_img = this;
            const fileSize = getFileSize(url).then(size => {
                detailsDiv.html(`
                    Dimensions: ${this_img.naturalWidth} x ${this_img.naturalHeight}<br>
                    File size: ${size}<br>
                    File type: ${getFileExtension(url)}
                `);
            });
        });
    
        modal.append("button")
            .text("Close")
            .on("click", () => modal.remove());
    }
    
    function getFileSize(url) {
        return fetch(url, { method: 'HEAD' })
            .then(response => {
                const size = response.headers.get('content-length');
                return formatFileSize(size);
            })
            .catch(() => 'Unknown');
    }
    
    function formatFileSize(bytes) {
        if (!bytes) return 'Unknown';
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) return '0 Byte';
        const i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
        return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
    }
    
    function getFileExtension(url) {
        return url.split('.').pop().toUpperCase();
    }
    
    function addEditButton(element, type) {
        element.append("button")
            .attr("class", "edit-element-button")
            .html("✎")
            .on("click", function() {
                switch (type) {
                    case "image":
                        addImage(null, null, null, element);
                        break;
                    case "thought":
                        addThought(null, null, null, element);
                        break;
                    case "place":
                        addPlace(null, null, null, element);
                        break;
                    case "tree":
                        addTree(null, null, null, element);
                        break;
                }
            });
    }

    function addDeleteButton(element) {
        element.append("button")
            .attr("class", "delete-element-button")
            .html("🗑")
            .on("click", function() {
                element.remove();
            });
    }
    
    function addTreeItem(container, parentId, level = 0) {
        const itemId = 'item_' + Math.random().toString(36).substr(2, 9);
        const item = container.append("div")
            .attr("class", "tree-item")
            .attr("data-id", itemId)
            .style("margin-left", `${level * 20}px`);
    
        item.append("input")
            .attr("type", "text")
            .attr("placeholder", level === 0 ? "Enter root name" : level === 1 ? "Enter trunk name" : "Enter branch name");
    
        item.append("button")
            .text("+")
            .on("click", function() {
                addTreeItem(item, itemId, level + 1);
            });
    
        if (parentId !== 'root') {
            item.append("button")
                .text("-")
                .on("click", function() {
                    item.remove();
                });
        }
    
        if (level > 0) {
            item.insert("div", ":first-child")
                .attr("class", "tree-line")
                .style("left", `${(level - 1) * 20 + 10}px`)
                .style("top", "50%")
                .style("width", "10px")
                .style("height", "1px");
        }
    
        return item;
    }
    
    function generateTreeData(treeContent) {
        function processNode(node) {
            const data = { name: node.select("input").property("value"), children: [] };
            node.selectAll(":scope > .tree-item").each(function() {
                data.children.push(processNode(d3.select(this)));
            });
            return data;
        }
        return processNode(treeContent.select(".tree-item"));
    }
    
    function renderTree(container, data) {
    const treeId = container.attr("data-tree-id") || generateElementId();
    container.attr("data-tree-id", treeId);

    // Preserve existing buttons
    const existingButtons = container.selectAll("button").remove();

    // Clear existing content except buttons
    container.selectAll("*:not(button)").remove();

    const root = d3.hierarchy(data);
    const treeLayout = d3.tree().size([180, 180]);
    const treeData = treeLayout(root);

    const svg = container.append("svg")
        .attr("width", "100%")
        .attr("height", "200")
        .attr("viewBox", "0 0 200 200")
        .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g")
        .attr("transform", "translate(10,10)");

    const link = g.selectAll(".link")
        .data(treeData.links())
        .enter().append("path")
        .attr("class", "link")
        .attr("d", d3.linkHorizontal()
            .x(d => d.y)
            .y(d => d.x));

    const node = g.selectAll(".node")
        .data(treeData.descendants())
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.y},${d.x})`);

    node.append("circle")
        .attr("r", 4);

    node.append("text")
        .attr("dy", ".31em")
        .attr("x", d => d.children ? -8 : 8)
        .style("text-anchor", d => d.children ? "end" : "start")
        .text(d => d.data.name)
        .on("click", function(event, d) {
            const newText = prompt("Enter new text:", d.data.name);
            if (newText !== null) {
                d.data.name = newText;
                d3.select(this).text(newText);
                updateTreeElement(container);
            }
        });

    node.append("text")
        .attr("dy", ".31em")
        .attr("x", d => d.children ? -20 : 20)
        .style("text-anchor", d => d.children ? "end" : "start")
        .text("🌳")
        .on("click", function(event, d) {
            openEditTreeModal(container, null, d.data.name);
        });

        renderTreeWithOrientation(container, data, container.attr("data-orientation") || "horizontal");
  

    // Re-add the existing buttons
    existingButtons.each(function() {
        container.node().appendChild(this);

    // Add toggle button
    svg.append("text")
        .attr("x", 180)
        .attr("y", 20)
        .text("↻")
        .style("font-size", "20px")
        .style("cursor", "pointer")
        .on("click", () => toggleTreeOrientation(container));    
    });
}

function toggleTreeOrientation(container) {
    const treeData = JSON.parse(container.attr("data-tree"));
    const currentOrientation = container.attr("data-orientation") || "horizontal";
    const newOrientation = currentOrientation === "horizontal" ? "vertical" : "horizontal";
    container.attr("data-orientation", newOrientation);
    renderTreeWithOrientation(container, treeData, newOrientation);
}
function renderTreeWithOrientation(container, data, orientation) {
    container.selectAll("svg").remove();
    container.selectAll(".tree-orientation-button").remove();

    // Add toggle button container
    const buttonContainer = container.append("div")
        .attr("class", "tree-orientation-button")
        .on("click", () => toggleTreeOrientation(container));

    buttonContainer.append("span")
        .text("↻");

    const svg = container.append("svg")
        .attr("width", "100%")
        .attr("height", orientation === "vertical" ? "300" : "200")
        .attr("viewBox", orientation === "vertical" ? "0 0 200 300" : "0 0 200 200")
        .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g")
        .attr("transform", "translate(10,10)");

   

    const root = d3.hierarchy(data);
    const treeLayout = orientation === "vertical" 
        ? d3.tree().size([180, 280])
        : d3.tree().size([180, 180]);
    const treeData = treeLayout(root);

    const link = g.selectAll(".link")
        .data(treeData.links())
        .enter().append("path")
        .attr("class", "link")
        .attr("d", orientation === "vertical"
            ? d3.linkVertical().x(d => d.x).y(d => d.y)
            : d3.linkHorizontal().x(d => d.y).y(d => d.x));

    const node = g.selectAll(".node")
        .data(treeData.descendants())
        .enter().append("g")
        .attr("class", "node")
        .attr("transform", d => orientation === "vertical"
            ? `translate(${d.x},${d.y})`
            : `translate(${d.y},${d.x})`);

    node.append("circle")
        .attr("r", 4);

    node.append("text")
        .attr("dy", ".31em")
        .attr("x", d => orientation === "vertical"
            ? (d.children ? -8 : 8)
            : (d.children ? -8 : 8))
        .style("text-anchor", d => orientation === "vertical"
            ? (d.children ? "end" : "start")
            : (d.children ? "end" : "start"))
        .text(d => d.data.name)
        .on("click", function(event, d) {
            const newText = prompt("Enter new text:", d.data.name);
            if (newText !== null) {
                d.data.name = newText;
                d3.select(this).text(newText);
                updateTreeElement(container);
            }
        });

    node.append("text")
        .attr("dy", ".31em")
        .attr("x", d => orientation === "vertical"
            ? (d.children ? -20 : 20)
            : (d.children ? -20 : 20))
        .style("text-anchor", d => orientation === "vertical"
            ? (d.children ? "end" : "start")
            : (d.children ? "end" : "start"))
        .text("🌳")
        .on("click", function(event, d) {
            openEditTreeModal(container, null, d.data.name);
        });
}

function updateTreeElement(container) {
    const treeData = JSON.parse(container.attr("data-tree"));
    const orientation = container.attr("data-orientation") || "horizontal";
    container.attr("data-tree", JSON.stringify(treeData));
    renderTreeWithOrientation(container, treeData, orientation);

    const gridId = container.attr("data-grid-id");
    if (gridId) {
        updateGridTree(gridId, treeData);
    }
}
    
    function openEditTreeModal(container, nodeData, nodeNameToAddChild = null) {
        const treeData = JSON.parse(container.attr("data-tree"));
        if (nodeNameToAddChild) {
            function addNodeToTree(treeNode, targetNodeName) {
                if (treeNode.name === targetNodeName) {
                    if (!treeNode.children) treeNode.children = [];
                    treeNode.children.push({ name: "New Node" });
                    return true;
                } else if (treeNode.children) {
                    for (let child of treeNode.children) {
                        if (addNodeToTree(child, targetNodeName)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            addNodeToTree(treeData, nodeNameToAddChild);
        }
        addTree(null, null, null, container, treeData);
    }
    
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    const svg = d3.select("#mindmap-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);
    
    const g = svg.append("g");
    
    let data = {
        id: generateNodeId(),
        name: "Central Idea",
        children: []
    };
    
    svg.append("defs").append("marker")
    .attr("id", "arrowhead")
    .attr("viewBox", "-0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", 0)
    .attr("orient", "auto")
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("xoverflow", "visible")
    .append("svg:path")
    .attr("d", "M 0,-5 L 10 ,0 L 0,5")
    .attr("fill", "#00ff00")
    .style("stroke", "none");

    const colorOptions = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'];
    

    let showGrid = false;
    const gridSize = 50;

    function gridForce() {
        let nodes;

        function force(alpha) {
            for (let node of nodes) {
                const gridX = Math.round(node.x / gridSize) * gridSize;
                const gridY = Math.round(node.y / gridSize) * gridSize;
                node.x += (gridX - node.x) * alpha;
                node.y += (gridY - node.y) * alpha;
            }
        }

        force.initialize = function(_nodes) {
            nodes = _nodes;
        };

        return force;
    }

    const simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-500))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(30))
        .force("grid", gridForce());

    let selectedNode = null;

    let zoom = d3.zoom()
        .scaleExtent([0.1, 10])
        .on("zoom", zoomed);

    svg.call(zoom);

    function zoomed(event) {
    const { transform } = event;
    g.attr("transform", transform);

    const centerX = width / 2 - transform.x / transform.k;
    const centerY = height / 2 - transform.y / transform.k;
    simulation.force("center", d3.forceCenter(centerX, centerY));

    g.selectAll(".node")
        .attr("transform", d => `translate(${d.x},${d.y}) scale(${1 / transform.k})`);

    g.selectAll(".link")
        .attr("d", d => `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`);

    if (showGrid) {
        svg.select(".grid").attr("transform", `translate(${transform.x},${transform.y}) scale(${transform.k})`);
        svg.selectAll(".grid .thick, .grid .selected").attr("stroke-width", 5 / transform.k);
        svg.selectAll(".grid-label").attr("font-size", 24 / transform.k);
    }
    updateMiniMap();
    updateCoordinateInputs(transform);
    }

    function updateCoordinateInputs(transform) {
    const xInput = document.getElementById('x-coordinate');
    const yInput = document.getElementById('y-coordinate');

    // Calculate the center of the current view in grid coordinates
    const centerX = (-transform.x + width / 2) / transform.k;
    const centerY = (-transform.y + height / 2) / transform.k;

    // Convert to grid line numbers (assuming every 50th line is a major line)
    const gridX = Math.round(centerX / (gridSize * 50));
    const gridY = Math.round(centerY / (gridSize * 50));

    xInput.value = gridX;
    yInput.value = gridY;
    }

    function createGrid() {
    const gridWidth = 5000 * gridSize;
    const gridHeight = 5000 * gridSize;

    const gridGroup = svg.insert("g", ":first-child")
        .attr("class", "grid")
        .attr("pointer-events", "none");

    // Create vertical lines
    for (let x = 0; x <= gridWidth; x += gridSize) {
        if (x % (gridSize * 50) === 0) {
            gridGroup.append("line")
                .attr("x1", x)
                .attr("y1", 0)
                .attr("x2", x)
                .attr("y2", gridHeight)
                .attr("class", "thick")
                .attr("pointer-events", "all")
                .on("click", function() {
                    d3.select(this).classed("selected", !d3.select(this).classed("selected"));
                    updateZones();
                    updateMiniMap();
                });

            // Add label at the top
            gridGroup.append("text")
                .attr("class", "grid-label")
                .attr("x", x)
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .text(x / (gridSize * 50));

            // Add label at the bottom
            gridGroup.append("text")
                .attr("class", "grid-label")
                .attr("x", x)
                .attr("y", gridHeight - 20)
                .attr("text-anchor", "middle")
                .text(x / (gridSize * 50));
        } else {
            gridGroup.append("line")
                .attr("x1", x)
                .attr("y1", 0)
                .attr("x2", x)
                .attr("y2", gridHeight);
        }
    }

    // Create horizontal lines
    for (let y = 0; y <= gridHeight; y += gridSize) {
        if (y % (gridSize * 50) === 0) {
            gridGroup.append("line")
                .attr("x1", 0)
                .attr("y1", y)
                .attr("x2", gridWidth)
                .attr("y2", y)
                .attr("class", "thick")
                .attr("pointer-events", "all")
                .on("click", function() {
                    d3.select(this).classed("selected", !d3.select(this).classed("selected"));
                    updateZones();
                    updateMiniMap();
                });

            // Add label on the left
            gridGroup.append("text")
                .attr("class", "grid-label")
                .attr("x", 20)
                .attr("y", y)
                .attr("dy", "0.35em")
                .attr("text-anchor", "start")
                .text(y / (gridSize * 50));

            // Add label on the right
            gridGroup.append("text")
                .attr("class", "grid-label")
                .attr("x", gridWidth - 20)
                .attr("y", y)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .text(y / (gridSize * 50));
        } else {
            gridGroup.append("line")
                .attr("x1", 0)
                .attr("y1", y)
                .attr("x2", gridWidth)
                .attr("y2", y);
        }
    }

    gridGroup.attr("transform", `translate(${-gridWidth/2},${-gridHeight/2})`);
    return gridGroup;
    }

    function setupGridNavigation() {
    const xInput = document.getElementById('x-coordinate');
    const yInput = document.getElementById('y-coordinate');

    xInput.addEventListener('change', () => navigateToGridPosition());
    yInput.addEventListener('change', () => navigateToGridPosition());
    }

    function clearRedLines() {
    svg.selectAll(".grid .selected")
        .classed("selected", false);
    updateZones();
    updateMiniMap();
    }

    function setupMiniMapControls() {
    d3.select("#reset-mini-map").on("click", () => {
        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2));
        updateMiniMap();
    });

    d3.select("#focus-mini-map").on("click", () => {
        const gridWidth = 5000 * gridSize;
        const scale = Math.min(width / gridWidth, height / gridWidth);
        const translateX = (width - gridWidth * scale) / 2;
        const translateY = (height - gridWidth * scale) / 2;

        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
        updateMiniMap();
    });

    d3.select("#clear-red-lines").on("click", clearRedLines);
    }

    function navigateToGridPosition() {
    const xInput = document.getElementById('x-coordinate');
    const yInput = document.getElementById('y-coordinate');
    
    const x = parseInt(xInput.value) || 0;
    const y = parseInt(yInput.value) || 0;

    const gridX = x * gridSize * 50; // Assuming every 50th line is a major line
    const gridY = y * gridSize * 50;

    // Calculate the center of the viewport
    const viewportCenterX = width / 2;
    const viewportCenterY = height / 2;

    // Calculate the translation needed to center the selected grid position
    const translateX = viewportCenterX - gridX;
    const translateY = viewportCenterY - gridY;

    // Use D3's zoom transform to move to the new position
    svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity
            .translate(translateX, translateY)
            .scale(1) // You can adjust this if you want to zoom in/out
        );
    }

    function updateZones() {
        const selectedLines = svg.select(".grid").selectAll(".selected");
        const zones = [];

        selectedLines.each(function() {
            const line = d3.select(this);
            const x1 = parseFloat(line.attr("x1"));
            const y1 = parseFloat(line.attr("y1"));
            const x2 = parseFloat(line.attr("x2"));
            const y2 = parseFloat(line.attr("y2"));

            if (x1 === x2) {
                zones.push({ type: "vertical", x: x1 });
            } else {
                zones.push({ type: "horizontal", y: y1 });
            }
        });

        g.selectAll(".node").each(function(d) {
            const node = d3.select(this);
            const x = d.x;
            const y = d.y;

            let inZone = false;
            for (let i = 0; i < zones.length - 1; i++) {
                const zone1 = zones[i];
                const zone2 = zones[i + 1];

                if (zone1.type === "vertical" && zone2.type === "vertical") {
                    if (x > zone1.x && x < zone2.x) {
                        inZone = true;
                        break;
                    }
                } else if (zone1.type === "horizontal" && zone2.type === "horizontal") {
                    if (y > zone1.y && y < zone2.y) {
                        inZone = true;
                        break;
                    }
                }
            }

            node.select("circle").style("stroke", inZone ? "#ff0000" : "none");
        });
    }

    function update(data) {
    const root = d3.hierarchy(data);
    const links = root.links();
    const nodes = root.descendants();

    nodes.forEach(node => {
        if (node.data.x !== undefined && node.data.y !== undefined) {
            node.x = node.data.x;
            node.y = node.data.y;
            node.fx = node.data.x;
            node.fy = node.data.y;
        }
    });

    simulation.nodes(nodes);
    simulation.force("link").links(links);

    let link = g.selectAll(".link")
        .data(links, d => d.target.id);

    link.exit().remove();

    const linkEnter = link.enter().append("path")
        .attr("class", "link");

    link = linkEnter.merge(link);

    let node = g.selectAll(".node")
        .data(nodes, d => d.id);

    node.exit().remove();

    const nodeEnter = node.enter().append("g")
        .attr("class", "node")
        .on("click", clicked)
        .on("contextmenu", showContextMenu)
        .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

   // Add Bark circles first (so they're behind the node circle)
nodeEnter.append("circle")
    .attr("class", "bark")
    .attr("r", 15)
    .style("fill", d => d.data.spaceAssigned ? "#e6ffe6" : "white")
    .style("stroke", d => d.data.spaceAssigned ? "white" : "darkgray")
    .style("stroke-width", 1)
    .call(d3.drag()
        .on("start", dragBarkStarted)
        .on("drag", draggedBark)
        .on("end", dragBarkEnded));

// Then add the node circle
nodeEnter.append("circle")
    .attr("class", "node-circle")
    .attr("r", 10)
    .style("fill", d => d.data.color || colorOptions[0])
    .style("pointer-events", "all")
    .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

// Add the text last so it's on top
nodeEnter.append("text")
    .attr("dy", "0.31em")
    .attr("x", d => d.children ? -20 : 20)
    .style("text-anchor", d => d.children ? "end" : "start")
    .text(d => d.data.name)
    .on("dblclick", editText);

    nodeEnter.append("text")
        .attr("class", "node-id")
        .attr("dy", "1.5em")
        .attr("x", 0)
        .style("text-anchor", "middle")
        .style("font-size", "6px")
        .text(d => d.id);

        node = nodeEnter.merge(node);

    node.attr("transform", d => `translate(${d.x},${d.y})`);

    // Ensure bark circles are behind node circles
    node.each(function() {
        const nodeGroup = d3.select(this);
        nodeGroup.select(".bark").lower();
    });

    simulation.on("tick", () => {
        const transform = d3.zoomTransform(svg.node());

        link.attr("d", d => `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`);
        node.attr("transform", d => `translate(${d.x},${d.y}) scale(${1 / transform.k})`);

        updateInternodes();
    });

    updateInternodes();
    updateZones();
}

function dragBarkStarted(event, d) {
    d.fx = d.x;
    d.fy = d.y;
    d3.select(this).classed("dragging", true);
}

function draggedBark(event, d) {
    const draggedBark = d3.select(this);
    const dx = event.x - d.x;
    const dy = event.y - d.y;
    draggedBark.attr("transform", `translate(${dx},${dy})`);
    checkBarkOverlap(draggedBark, d, dx, dy);
}

function dragBarkEnded(event, d) {
    d.fx = null;
    d.fy = null;
    const draggedBark = d3.select(this);
    draggedBark.classed("dragging", false)
               .transition()
               .duration(300)
               .attr("transform", "translate(0,0)");
    handleBarkDrop(draggedBark, d);
}

function checkBarkOverlap(draggedBark, draggedData, dx, dy) {
    g.selectAll(".bark").each(function(d) {
        if (this !== draggedBark.node()) {
            const targetX = d.x;
            const targetY = d.y;
            const draggedX = draggedData.x + dx;
            const draggedY = draggedData.y + dy;
            const distance = Math.sqrt((targetX - draggedX)**2 + (targetY - draggedY)**2);
            
            if (distance < 30) {  // Adjust this value as needed
                d3.select(this).classed("overlapping", true);
                draggedBark.classed("overlapping", true);
            } else {
                d3.select(this).classed("overlapping", false);
            }
        }
    });
}

function handleBarkDrop(draggedBark, draggedData) {
    const draggedTransform = draggedBark.attr("transform");
    let draggedX = 0, draggedY = 0;
    
    if (draggedTransform) {
        const match = draggedTransform.match(/translate\(([^,]+),([^)]+)\)/);
        if (match) {
            draggedX = parseFloat(match[1]);
            draggedY = parseFloat(match[2]);
        }
    }

    g.selectAll(".bark").each(function(d) {
        if (this !== draggedBark.node()) {
            const targetX = d.x;
            const targetY = d.y;
            const distance = Math.sqrt((targetX - (draggedData.x + draggedX))**2 + (targetY - (draggedData.y + draggedY))**2);
            
            if (distance < 30) {  // Adjust this value as needed
                createInternode(draggedData, d);
            }
        }
        d3.select(this).classed("overlapping", false);
    });
    draggedBark.classed("overlapping", false);
}

function createInternode(source, target) {
    if (!source.data.internodes) source.data.internodes = [];
    if (!target.data.internodes) target.data.internodes = [];

    const existingInternode = source.data.internodes.find(i => i.target === target && i.source === source);

    if (!existingInternode) {
        const internode = { source: source, target: target };
        source.data.internodes.push(internode);
        target.data.internodes.push(internode);
        updateInternodes();
    }
}

function updateInternodes() {
    const internodes = g.selectAll(".internode")
        .data(getInternodes(), d => `${d.source.id}-${d.target.id}`);

    internodes.exit().remove();

    const internodeEnter = internodes.enter().append("g")
        .attr("class", "internode");

    internodeEnter.append("path")
        .attr("marker-end", "url(#arrowhead)")
        .attr("fill", "none")
        .attr("stroke", "#666")  // Darker gray
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "4,4");  // Dotted line

    internodeEnter.merge(internodes)
        .select("path")
        .attr("d", d => {
            const sourceX = d.source.x;
            const sourceY = d.source.y;
            const targetX = d.target.x;
            const targetY = d.target.y;
            return `M${sourceX},${sourceY}L${targetX},${targetY}`;
        });

    internodeEnter.on("contextmenu", removeInternode);
}

function getTranslation(transform) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttributeNS(null, "transform", transform);
    const matrix = g.transform.baseVal.consolidate().matrix;
    return [matrix.e, matrix.f];
}

function getInternodes() {
    const internodes = [];
    g.selectAll(".node").each(function(d) {
        if (d.data.internodes) {
            internodes.push(...d.data.internodes);
        }
    });
    return internodes;
}

function removeInternode(event, d) {
    event.preventDefault();
    d.source.data.internodes = d.source.data.internodes.filter(i => i !== d);
    d.target.data.internodes = d.target.data.internodes.filter(i => i !== d);
    updateInternodes();
}

    let selectedNodeData = null;

    

function clicked(event, d) {
    if (selectedNode) {
        d3.select(selectedNode).select("circle").classed("selected", false);
        d3.select(selectedNode).select("text").classed("selected", false).style("fill", null);
    }
    selectedNode = this;
    selectedNodeData = d;
    d3.select(this).select("circle").classed("selected", true);
    d3.select(this).select("text").classed("selected", true).style("fill", "#2ca02c");
    updateSpaceWindowHeaders(d);
    event.stopPropagation();
}

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        const dx = event.x - d.x;
        const dy = event.y - d.y;
        d.x = event.x;
        d.y = event.y;
        d.fx = event.x;
        d.fy = event.y;

        if (d.children) {
            moveChildren(d, dx, dy);
        }
    }

    function dragged(event, d) {
    const dx = event.x - d.x;
    const dy = event.y - d.y;
    d.x = event.x;
    d.y = event.y;
    d.fx = event.x;
    d.fy = event.y;

    if (d.children) {
        moveChildren(d, dx, dy);
    }

    // Move internodes connected to this node
    if (d.data.internodes) {
        d.data.internodes.forEach(internode => {
            if (internode.source === d) {
                internode.target.x += dx;
                internode.target.y += dy;
            } else if (internode.target === d) {
                internode.source.x += dx;
                internode.source.y += dy;
            }
        });
    }

    updateInternodes();
}

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = d.x;
        d.fy = d.y;
        d.data.x = d.x;
        d.data.y = d.y;
    }

    function editText(event, d) {
        event.stopPropagation();
        const node = d3.select(this.parentNode);
        const text = node.select("text");
        const textElement = text.node();

        const editField = d3.select("body").append("div")
            .attr("class", "edit-field")
            .style("left", (event.pageX - 50) + "px")
            .style("top", (event.pageY - 15) + "px");

        const input = editField.append("input")
            .attr("type", "text")
            .attr("value", d.data.name)
            .on("keyup", function(event) {
                if (event.key === "Enter") confirmEdit();
                if (event.key === "Escape") cancelEdit();
            });

        editField.append("button")
            .html("✓")
            .on("click", confirmEdit);

        editField.append("button")
            .html("✗")
            .on("click", cancelEdit);

        input.node().focus();

        function confirmEdit() {
            d.data.name = input.node().value;
            text.text(d.data.name);
            editField.remove();
        }

        function cancelEdit() {
            editField.remove();
        }
    }

    function showContextMenu(event, d) {
    event.preventDefault();

    d3.select(".context-menu").remove();

    const contextMenu = d3.select("body").append("div")
        .attr("class", "context-menu")
        .style("left", (event.pageX + 5) + "px")
        .style("top", (event.pageY + 5) + "px");

    addMenuSection(contextMenu, "Selected Node", [d.data.name], "selected-node");
    addMenuSection(contextMenu, "Node ID", [d.data.id], "node-id");
    addMenuSection(contextMenu, "Actions", ["Add Child", "Remove Node", "Edit Text", "Add Space"]);
    addColorSection(contextMenu, d);
    addAssignedSpacesSection(contextMenu, d);

    d3.select("body").on("click.context-menu", () => {
        d3.select(".context-menu").remove();
        d3.select("body").on("click.context-menu", null);
    });

    function addAssignedSpacesSection(menu, nodeData) {
    const assignedSpaces = d3.selectAll(".space-window")
        .filter(function() {
            return d3.select(this).attr("data-assigned-node") === nodeData.data.id;
        });

    if (assignedSpaces.size() > 0) {
        const section = menu.append("div").attr("class", "context-menu-section");
        section.append("div").text("Assigned Spaces");
        assignedSpaces.each(function() {
            const spaceWindow = d3.select(this);
            section.append("div")
                .text(spaceWindow.select(".space-window-title").text())
                .on("click", () => {
                    spaceWindow.style("display", "block");
                    centerSpaceWindow(spaceWindow);
                });
        });
    }
}

function centerSpaceWindow(spaceWindow) {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    const spaceWidth = parseFloat(spaceWindow.style("width"));
    const spaceHeight = parseFloat(spaceWindow.style("height"));

    spaceWindow
        .style("left", `${(windowWidth - spaceWidth) / 2}px`)
        .style("top", `${(windowHeight - spaceHeight) / 2}px`);
}

function addMenuSection(menu, title, items, className = "") {
        const section = menu.append("div").attr("class", "context-menu-section");
        section.append("div").text(title);
        items.forEach(item => {
            section.append("div")
                .text(item)
                .attr("class", className)
                .on("click", () => handleContextMenuAction(d, item));
        });
        if (className === "node-id") {
            section.selectAll("div:not(:first-child)")
                .style("font-size", "8px")
                .style("color", "#666")
                .style("word-break", "break-all");
        }
    }

    function addColorSection(menu, nodeData) {
        const section = menu.append("div").attr("class", "context-menu-section");
        section.append("div").text("Color");

        const colorContainer = section.append("div").attr("class", "color-container");
        colorOptions.forEach(color => {
            colorContainer.append("div")
                .attr("class", "color-option")
                .style("background-color", color)
                .on("click", () => handleContextMenuAction(nodeData, color));
        });
    }
}

function handleContextMenuAction(d, action) {
    switch(action) {
        case "Add Child":
            addChild(d);
            break;
        case "Remove Node":
            removeNode(d);
            break;
        case "Edit Text":
            editNodeText(d);
            break;
        case "Add Space":
            createSpaceWindow(d);
            break;
        default:
            if (colorOptions.includes(action)) {
                d.data.color = action;
                update(data);
            }
    }
}


    function addChild(d) {
        const newNode = {
            id: generateNodeId(),
            name: "New Concept",
            x: d.x + (Math.random() - 0.5) * 100,
            y: d.y + (Math.random() - 0.5) * 100,
            color: colorOptions[Math.floor(Math.random() * colorOptions.length)]
        };
        if (!d.data.children) d.data.children = [];
        d.data.children.push(newNode);
        update(data);
        simulation.alpha(1).restart();
    }

    function removeNode(d) {
        if (d.parent) {
            const index = d.parent.data.children.indexOf(d.data);
            if (index > -1) {
                d.parent.data.children.splice(index, 1);
                update(data);
                selectedNode = null;
                simulation.alpha(1).restart();
            }
        }
    }

    function editNodeText(d) {
        const node = d3.select(d3.selectAll(".node").filter(n => n.id === d.id).node());
        const text = node.select("text");

        const editField = d3.select("body").append("div")
            .attr("class", "edit-field")
            .style("left", (d.x + 10) + "px")
            .style("top", (d.y - 15) + "px");

        const input = editField.append("input")
            .attr("type", "text")
            .attr("value", d.data.name)
            .on("keyup", function(event) {
                if (event.key === "Enter") confirmEdit();
                if (event.key === "Escape") cancelEdit();
            });

        editField.append("button")
            .html("✓")
            .on("click", confirmEdit);

        editField.append("button")
            .html("✗")
            .on("click", cancelEdit);

        input.node().focus();

        function confirmEdit() {
            d.data.name = input.node().value;
            text.text(d.data.name);
            editField.remove();
        }

        function cancelEdit() {
            editField.remove();
        }
    }

    function createSpaceWindow(node) {
    const spaceWindow = d3.select("#space-windows").append("div")
        .attr("class", "space-window")
        .style("left", `${node.x}px`)
        .style("top", `${node.y}px`)
        .style("width", "400px")
        .style("height", "225px")
        .attr("data-space-id", generateSpaceId());

    const header = spaceWindow.append("div")
        .attr("class", "space-window-header");

    header.append("span")
        .attr("class", "space-window-title")
        .text("New Space")
        .on("dblclick", editSpaceWindowTitle);

    header.append("span")
        .attr("class", "space-window-node-info")
        .style("color", "red")
        .style("margin", "0 10px");

    header.append("span")
        .attr("class", "space-window-pin")
        .html("📌")
        .style("cursor", "pointer")
        .on("click", toggleSpaceAssignment);

    const controlsContainer = header.append("div")
        .attr("class", "space-window-controls");

    controlsContainer.append("span")
        .attr("class", "space-window-minimize")
        .html("−")
        .on("click", minimizeSpaceWindow);

    controlsContainer.append("span")
        .attr("class", "space-window-close")
        .html("&times;")
        .on("click", () => {
            unassignSpace(spaceWindow);
            spaceWindow.remove();
        });

    const buttonContainer = spaceWindow.append("div")
        .style("display", "flex")
        .style("justify-content", "space-between")
        .style("margin-bottom", "5px");

    buttonContainer.append("button")
        .attr("class", "add-element-button")
        .text("Add Element")
        .on("click", function(event) {
            showAddElementModal(spaceWindow, event);
        });

    buttonContainer.append("button")
        .attr("class", "add-column-button")
        .text("ADD COLUMN")
        .on("click", function() {
            addColumn(content);
        });

    const content = spaceWindow.append("div")
        .attr("class", "space-window-content")
        .style("display", "flex")
        .style("flex-wrap", "wrap");

    addColumn(content);

    spaceWindow.append("div")
        .attr("class", "resize-handle");

    spaceWindow.call(d3.drag()
        .on("start", dragSpaceWindowStart)
        .on("drag", dragSpaceWindow)
        .on("end", dragSpaceWindowEnd));

    spaceWindow.select(".resize-handle").call(d3.drag()
        .on("drag", resizeSpaceWindow));

    const resizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
            const height = entry.contentRect.height;
            content.selectAll(".space-window-column")
                .style("height", `${height - 60}px`);
        }
    });
    resizeObserver.observe(spaceWindow.node());

    return spaceWindow;
}

function generateSpaceId() {
    return 'space_' + Math.random().toString(36).substr(2, 9);
}

function generateSpaceId() {
    return 'space_' + Math.random().toString(36).substr(2, 9);
}

function updateSpaceWindowHeaders(selectedNode) {
    d3.selectAll(".space-window").each(function() {
        const spaceWindow = d3.select(this);
        const nodeInfo = spaceWindow.select(".space-window-node-info");
        const pin = spaceWindow.select(".space-window-pin");

        if (spaceWindow.attr("data-assigned-node")) {
            // Space is assigned, keep the assigned node info
            return;
        }

        if (selectedNode) {
            nodeInfo.text(`${selectedNode.data.name} (${selectedNode.data.id})`)
                .style("color", "red");
            pin.style("display", "inline");
        } else {
            nodeInfo.text("")
            pin.style("display", "none");
        }
    });
}

function toggleSpaceAssignment() {
    const spaceWindow = d3.select(this.parentNode.parentNode);
    const nodeInfo = spaceWindow.select(".space-window-node-info");
    const assignedNodeId = spaceWindow.attr("data-assigned-node");

    if (assignedNodeId) {
        // Unassign
        unassignSpace(spaceWindow);
    } else if (selectedNode) {
        // Assign
        spaceWindow.attr("data-assigned-node", selectedNode.data.id);
        nodeInfo.style("color", "green");
        d3.select(this).style("color", "red");
        updateNodeContextMenu(selectedNode);
    }
}

function unassignSpace(spaceWindow) {
    const assignedNodeId = spaceWindow.attr("data-assigned-node");
    if (assignedNodeId) {
        spaceWindow.attr("data-assigned-node", null);
        spaceWindow.select(".space-window-node-info").style("color", "red");
        spaceWindow.select(".space-window-pin").style("color", "green");
        updateNodeContextMenu(findNodeById(assignedNodeId));
    }
}

function findNodeById(id) {
    return d3.hierarchy(data).descendants().find(node => node.data.id === id);
}

function updateNodeContextMenu(node) {
    const openContextMenu = d3.select(".context-menu");
    if (openContextMenu.size() > 0 && openContextMenu.datum() === node) {
        showContextMenu(d3.event, node);
    }
}

function updateSpaceWindowHeaders(selectedNode) {
    d3.selectAll(".space-window").each(function() {
        const spaceWindow = d3.select(this);
        const nodeInfo = spaceWindow.select(".space-window-node-info");
        const pin = spaceWindow.select(".space-window-pin");

        if (spaceWindow.attr("data-assigned-node")) {
            // Space is assigned, keep the assigned node info
            return;
        }

        if (selectedNode) {
            nodeInfo.text(`${selectedNode.data.name} (${selectedNode.data.id})`)
                .style("color", "red");
            pin.style("display", "inline");
        } else {
            nodeInfo.text("")
            pin.style("display", "none");
        }
    });
}

function toggleSpaceAssignment() {
    const spaceWindow = d3.select(this.parentNode.parentNode);
    const nodeInfo = spaceWindow.select(".space-window-node-info");
    const pin = d3.select(this);
    const assignedNodeId = spaceWindow.attr("data-assigned-node");

    if (assignedNodeId) {
        // Unassign
        unassignSpace(spaceWindow);
    } else if (selectedNodeData) {
        // Assign
        spaceWindow.attr("data-assigned-node", selectedNodeData.data.id);
        nodeInfo.text(`${selectedNodeData.data.name} (${selectedNodeData.data.id})`)
            .style("color", "green");
        pin.style("color", "green");
        updateNodeContextMenu(selectedNodeData);
    }
}

function unassignSpace(spaceWindow) {
    const assignedNodeId = spaceWindow.attr("data-assigned-node");
    if (assignedNodeId) {
        spaceWindow.attr("data-assigned-node", null);
        const nodeInfo = spaceWindow.select(".space-window-node-info");
        const pin = spaceWindow.select(".space-window-pin");
        
        if (selectedNodeData) {
            nodeInfo.text(`${selectedNodeData.data.name} (${selectedNodeData.data.id})`)
                .style("color", "red");
        } else {
            nodeInfo.text("").style("color", "red");
        }
        
        pin.style("color", "green");
        updateNodeContextMenu(findNodeById(assignedNodeId));
    }
}

function findNodeById(id) {
    return d3.hierarchy(data).descendants().find(node => node.data.id === id);
}

function updateNodeContextMenu(node) {
    const openContextMenu = d3.select(".context-menu");
    if (openContextMenu.size() > 0 && openContextMenu.datum() === node) {
        showContextMenu({pageX: parseFloat(openContextMenu.style("left")), pageY: parseFloat(openContextMenu.style("top"))}, node);
    }
}

    function editSpaceWindowTitle(event) {
        const headerSpan = d3.select(this);
        const currentTitle = headerSpan.text();

        const input = headerSpan.html("")
            .append("input")
            .attr("type", "text")
            .attr("value", currentTitle)
            .style("font-size", "12px")
            .style("width", "80%")
            .on("blur", confirmEdit)
            .on("keyup", function(event) {
                if (event.key === "Enter") confirmEdit();
                if (event.key === "Escape") cancelEdit();
            });

        input.node().focus();

        function confirmEdit() {
            const newTitle = input.property("value");
            headerSpan.html(newTitle);
        }

        function cancelEdit() {
            headerSpan.html(currentTitle);
        }
    }
    function minimizeSpaceWindow() {
    const spaceWindow = d3.select(this.closest('.space-window'));
    spaceWindow.style("display", "none");
    }

    function resizeSpaceWindow(event) {
        const spaceWindow = d3.select(this.parentNode);
        const width = parseFloat(spaceWindow.style("width")) + event.dx;
        const height = parseFloat(spaceWindow.style("height")) + event.dy;
        spaceWindow.style("width", `${width}px`).style("height", `${height}px`);
    }

    function dragSpaceWindowStart(event) {
        d3.select(this).select(".space-window-header").style("cursor", "grabbing");
    }

    function dragSpaceWindow(event) {
        const spaceWindow = d3.select(this);
        const left = parseFloat(spaceWindow.style("left")) + event.dx;
        const top = parseFloat(spaceWindow.style("top")) + event.dy;
        spaceWindow.style("left", `${left}px`).style("top", `${top}px`);
    }

    function dragSpaceWindowEnd(event) {
        d3.select(this).select(".space-window-header").style("cursor", "move");
    }

    function addColumn(content) {
        const column = content.append("div")
            .attr("class", "space-window-column")
            .style("flex", "1 0 200px")
            .style("min-width", "200px")
            .style("max-width", "400px")
            .style("margin", "5px")
            .style("padding", "5px")
            .style("border", "1px solid #ccc")
            .style("border-radius", "5px")
            .style("position", "relative");

        column.append("button")
            .attr("class", "remove-column-button")
            .html("&times;")
            .style("position", "absolute")
            .style("top", "5px")
            .style("right", "5px")
            .style("font-size", "10px")
            .style("padding", "2px 4px")
            .on("click", function() {
                if (column.selectAll(".space-element").size() > 0) {
                    showToast("Elements must be removed from a Column first before removing a Column.");
                } else {
                    column.remove();
                }
            });
    }

    function showToast(message) {
        const toast = d3.select("body").append("div")
            .attr("class", "toast-message")
            .text(message)
            .style("position", "fixed")
            .style("bottom", "20px")
            .style("left", "50%")
            .style("transform", "translateX(-50%)")
            .style("background-color", "rgba(0, 0, 0, 0.7)")
            .style("color", "#fff")
            .style("padding", "10px 20px")
            .style("border-radius", "5px")
            .style("opacity", 0);

        toast.transition()
            .duration(200)
            .style("opacity", 1);

        setTimeout(() => {
            toast.transition()
                .duration(500)
                .style("opacity", 0)
                .remove();
        }, 3000);
    }

    d3.select("#mini-menu").style("display", "none");

    d3.select("#reset-zoom").on("click", () => {
        svg.transition()
            .duration(750)
            .call(zoom.transform, d3.zoomIdentity);
    });

    d3.select("#toggle-grid").on("click", () =>
    {
        showGrid = !showGrid;
        if (showGrid) {
            if (!svg.select(".grid").size()) {
                createGrid();
            }
            svg.select(".grid").style("display", "block");
        } else {
            svg.select(".grid").style("display", "none");
        }
        d3.select("#toggle-grid").classed("active", showGrid);
        handleButtonClick("toggle-grid");
    });

    d3.select("#toggle-help").on("click", () => {
        const miniMenu = d3.select("#mini-menu");
        miniMenu.style("display", miniMenu.style("display") === "none" ? "block" : "none");
    });

    function handleButtonClick(buttonId) {
        const button = d3.select(`#${buttonId}`);
        button.transition()
            .duration(100)
            .style("transform", "scale(0.95)")
            .transition()
            .duration(100)
            .style("transform", "scale(1)");
    }

    function createMiniMap() {
        const miniMapSize = 200;
        const gridWidth = 5000 * gridSize;
        let miniMapScale = miniMapSize / gridWidth;

        const miniMap = d3.select("#mini-map")
            .append("svg")
            .attr("width", miniMapSize)
            .attr("height", miniMapSize);

        const miniMapContent = miniMap.append("g");

        for (let x = 0; x <= gridWidth; x += gridSize) {
            miniMapContent.append("line")
                .attr("class", "mini-map-grid-line")
                .attr("x1", x * miniMapScale)
                .attr("y1", 0)
                .attr("x2", x * miniMapScale)
                .attr("y2", gridWidth * miniMapScale)
                .attr("stroke", "#e0e0e0")
                .attr("stroke-width", 1);
        }

        for (let y = 0; y <= gridWidth; y += gridSize) {
            miniMapContent.append("line")
                .attr("class", "mini-map-grid-line")
                .attr("x1", 0)
                .attr("y1", y * miniMapScale)
                .attr("x2", gridWidth * miniMapScale)
                .attr("y2", y * miniMapScale)
                .attr("stroke", "#e0e0e0")
                .attr("stroke-width", 1);
        }

        miniMapContent.append("g")
            .attr("class", "mini-map-red-lines");

        const viewportRect = miniMap.append("rect")
            .attr("class", "viewport")
            .attr("fill", "none")
            .attr("stroke", "#000")
            .attr("stroke-width", 2);

        function updateMiniMap() {
            const transform = d3.zoomTransform(svg.node());
            const vpWidth = width / transform.k;
            const vpHeight = height / transform.k;

            viewportRect
                .attr("x", (-transform.x / transform.k) * miniMapScale)
                .attr("y", (-transform.y / transform.k) * miniMapScale)
                .attr("width", vpWidth * miniMapScale)
                .attr("height", vpHeight * miniMapScale);

            miniMapContent.selectAll(".mini-map-node")
                .data(simulation.nodes())
                .join("circle")
                .attr("class", "mini-map-node")
                .attr("cx", d => d.x * miniMapScale)
                .attr("cy", d => d.y * miniMapScale)
                .attr("r", 1.25)
                .attr("fill", d => d.data.color || colorOptions[0]);

            const redLines = svg.selectAll(".grid .selected");
            const miniMapRedLines = miniMapContent.select(".mini-map-red-lines").selectAll(".mini-map-red-line")
                .data(redLines.nodes(), d => d.id);

            miniMapRedLines.exit().remove();

            miniMapRedLines.enter()
                .append("line")
                .attr("class", "mini-map-red-line")
                .merge(miniMapRedLines)
                .attr("x1", d => parseFloat(d3.select(d).attr("x1")) * miniMapScale)
                .attr("y1", d => parseFloat(d3.select(d).attr("y1")) * miniMapScale)
                .attr("x2", d => parseFloat(d3.select(d).attr("x2")) * miniMapScale)
                .attr("y2", d => parseFloat(d3.select(d).attr("y2")) * miniMapScale)
                .attr("stroke", "#ff0000")
                .attr("stroke-width", 1);
        }

        miniMap.on("click", function(event) {
            const [x, y] = d3.pointer(event);
            const targetX = x / miniMapScale;
            const targetY = y / miniMapScale;

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(1)
                    .translate(-targetX, -targetY));
        });

        d3.select("#reset-mini-map").on("click", () => {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2));
            updateMiniMap();
        });

        d3.select("#focus-mini-map").on("click", () => {
            const gridWidth = 5000 * gridSize;
            const scale = Math.min(width / gridWidth, height / gridWidth);
            const translateX = (width - gridWidth * scale) / 2;
            const translateY = (height - gridWidth * scale) / 2;

            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
            updateMiniMap();
        });

        return updateMiniMap;
    }

    const updateMiniMap = createMiniMap();

    d3.select("#add-child").on("click", () => {
        if (selectedNode) {
            const d = d3.select(selectedNode).datum();
            addChild(d);
        }
    });

    d3.select("#remove-node").on("click", () => {
        if (selectedNode) {
            const d = d3.select(selectedNode).datum();
            removeNode(d);
        }
    });

    d3.select("#save").on("click", () => {
        const mindMapData = JSON.stringify(data);
        localStorage.setItem("mindMapData", mindMapData);
        alert("Mind map saved.");
    });

    d3.select("#load").on("click", () => {
        const mindMapData = localStorage.getItem("mindMapData");
        if (mindMapData) {
            data = JSON.parse(mindMapData);
            update(data);
            alert("Mind map loaded.");
        } else {
            alert("No saved mind map found.");
        }
    });
    document.addEventListener('DOMContentLoaded', () => {
    setupGridNavigation();
    setupMiniMapControls();
    });
    document.addEventListener('DOMContentLoaded', setupGridNavigation);
    update(data);

    
    </script>
</body>

</html>
